# Dart 2 Migration Guide

- [Background](#background)
- [Changes Required for Dart 2 Compatibility](#changes-required-for-dart-2-compatibility)
- [Migration From Dart 1 to Dart 2](#migration-from-dart-1-to-dart-2)

## Background

As a part of the Dart SDK 2.0.0 release, support for transformers was removed and
builders were named the canonical replacement moving forward.

This library relied heavily on transformers to provide a developer experience
for building statically-typed React UI components in Dart with minimal overhead,
and we want to keep that promise moving forward.

If we set the migration process aside momentarily and look ahead to Dart 2, the
first takeaway is obviously that over_react needs to provide the same (or
similar) functionality provided by the Dart 1 transformer, but in the form of a
Dart 2-compatible builder. This process is not as straightforward as it may
seem, unfortunately, because the set of limitations imposed by the builder
pattern is more restrictive than with transformers (for good reason). In
particular, builders are **not** allowed to transform/augment/modify code
_inline_; all outputs must be written to separate files. The over_react
transformer leveraged inline transformations for quite a lot:

- Initializing component factories
- Generating component factory registrations
- Replacing uninitialized props and state fields with concrete getters and
  setters that map to the underlying, untyped `Map`s used by ReactJS.
- Generating wiring or implementations for a variety of APIs that require info
  about the component (i.e. cannot simply be inherited)
- etc.

A lot of this can be generated in a separate part file by a builder, but some of
the inline transformations are simply not possible with a builder approach.
Consequently, changes to the over_react component boilerplate are necessary in
order to support Dart 2.

## Changes Required for Dart 2 Compatibility

### Generated Part

For any file that includes a component definition, the builder will have to
generate code in a separate file which will have to be explicitly included.

```diff
  // foo.dart;
  library foo;

  import 'package:over_react/over_react.dart';

+ part 'foo.over_react.g.dart';

  @Factory() ...
  @Props() ...
  @Component() ...
```

### Component Factory

Previously, component factories were written as uninitialized top-level
variables. On Dart 2, the factory will need to be initialized to a symbol that
the builder will generate.

```diff
  @Factory()
- UiFactory<FooProps> Foo;
+ UiFactory<FooProps> Foo = $Foo;
```

In this example, `$Foo` would be generated by the builder.

### Props, State, AbstractProps, AbstractState

In order to support the generation of concrete getters/setters for props/state
fields while still maintaining the ability to extend props and state classes on
Dart 2, the classes you define will need to be named with a `_$` prefix. This
allows the builder to generate the public, un-prefixed version that will be used
everywhere else.

```diff
  @Props()
- class FooProps extends UiProps { ... }
+ class _$FooProps extends UiProps { ... }

  @State()
- class FooState extends UiState { ... }
+ class _$FooState extends UiState { ... }

  @AbstractProps()
- class AbstractFooProps extends UiProps { ... }
+ class _$AbstractFooProps extends UiProps { ... }

  @AbstractState()
- class AbstractFooState extends UiState { ... }
+ class _$AbstractFooState extends UiState { ... }
```

In this example, the builder would generate the `FooProps`, `FooState`,
`AbstractFooProps`, and `AbstractFooState` classes with concrete getters and
setters implemented. The `FooProps` class generated by the builder would look
like this:

```dart
class FooProps extends _$FooProps with _$FooPropsAccessorsMixin {}
```

Doing this allows for inheritence of Props and State classes to function as
expected. Since the public version of the class is generated and includes the
concrete getters and setters _as well_ as everything concrete that was defined
in the `_$` version, you or someone else can simply extend it. No additional
work by the builder required.

### Props and State Mixins

Similar to the non-mixin Props and State classes, Props and State mixins will
need to be written with a `_$` prefix so that the builder can generate the
public, un-prefixed version that will be used everywhere else.

```diff
  @PropsMixin()
- class FooPropsMixin {}
+ class _$FooPropsMixin {}

  @StateMixin()
- class FooStateMixin {}
+ class _$FooStateMixin {}
```

This change looks like the same change as the one above for Props and State
classes, but the builder support behind the scenes is a bit different. This is
because Dart prohibits mixing in classes that extend anything other than
`Object`, meaning that the approach used above for Props and State classes does
not work for Props and State mixins. Instead of generating a public version of
these mixins that extend the consumer-defined version, the builder will generate
a separate class that implements the consumer-defined mixin. This generated
class will have concrete getters and setters implemented for all of the fields
and any additional concrete methods, getters, and setters will be copied over.

An example:

```dart
@PropsMixin()
class _$FooPropsMixin {
  String foo;

  int get length => foo.length;
}

// generated by builder
class FooPropsMixin implements _$FooPropsMixin {
  String get foo => ...;
  set foo(String value) { ... };

  int get length => foo.length;
}
```

### `$Props()` and `$PropKeys()`

These two utility classes are provided by `over_react` as a way to obtain
metadata about a props class. `$Props()` acts as an iterable of the prop fields
defined by a given props class (most commonly used to populate the list of
`consumedProps` for a component), and `$PropKeys()` similarly acts as an
iterable of the string keys for these prop fields.

These utility classes are actually just proxy classes and the transformer
changes them inline to the appropriate formats. This does not work with builders
since inline transformations are disallowed.

This is solved by providing an alternative API to obtain the same information.
Because the builder is generating the public, un-prefixed versions of all the
Props and State classes and mixins, it can include a static `meta` field:

```dart
// generated by builder
class FooProps extends _$FooProps with _$FooPropsAccessorsMixin {
  static PropsMeta meta = $metaForFooProps;
}

const PropsMeta $metaForFooProps = const PropsMeta(
  fields: ...,
  keys: ...,
);
```

With this in place, existing usages of `$Props()` and `$PropKeys()` should be
migrated like so:

```diff
- const $Props(FooProps)
+ FooProps.meta

- const $PropKeys(FooProps)
+ FooProps.meta.keys
```

As an added bonus, this meta information becomes available for State classes as
well.

### Component Default Props

In some cases, obtaining the default props for a component can be useful. These
are defined via the component's `getDefaultProps()` method. The easiest way to
obtain these default props is to simply construct the component and call that
method. Unfortunately, constructing the component directly was never intended to
be a supported use case, and in Dart 2 this approach won't work because the
typed props factory implementation needs to be generated.

To work around around this, an alternative API for obtaining a component's
default props has been added:

```diff
- var defaultProps = new FooComponent().getDefaultProps();
+ var defaultProps = Foo().componentDefaultProps;
```

The `componentDefaultProps` getter returns the cached default props for the
component that the factory would eventually construct. One caveat: the getter is
typed as `Map`. If you need to obtain a component's default props typed as the
props class for that component, use the following utility:

```diff
- var defaultProps = new FooComponent().getDefaultProps();
+ var defaultProps = typedDefaultPropsFor(Foo);
```

## Migration From Dart 1 to Dart 2

Now that we've laid out the eventual destination, we need to explain how to get
there.

If you don't need to support a backwards-compatible migration path and just want
to get from Dart 1 to Dart 2 as quickly as possible, you have two options:

1. Update your code manually using the above diffs as a guide.
2. Use our [`over_react_migrate_from_dart1_to_dart2` codemod script][orcm-dart1-to-dart2]
   to automate the migration.

If, however, you do need migrate your `over_react` code from Dart 1 to Dart 2
in a backwards- and forwards-compatible manner, you'll need to take a two-step
approach:

### 1. Migrate to the Forwards- and Backwards-compatible Setup

Use our [`over_react_migrate_to_dart1_and_dart2` codemod script][orcm-dart1-to-dart1-and-dart2]
to update your code to a state that is compatible with both the Dart 1
transformer and the Dart 2 builder. _In this state, you will notice some extra
boilerplate and comments. This will be cleaned up in the second step, but is
necessary during the transition._

If the transition may take a while, you can use that same codemod script as a CI
check to prevent regressions – just add the `--check` flag.

While in this state, you should also update your package's `pubspec.yaml` to
include both the 1.x and 2.x versions of the Dart SDK:

```yaml
environment:
  sdk: ">=1.24.3 <3.0.0"
```

When running on Dart 2, the Dart 2-compatible version of over_react will be
installed and your over_react code will run with the builder.

When running on Dart 1, the Dart 1-compatible version of over_react will be
installed and your over_react code will run with the transformer as it currently
does.

### 2. Migrate to the Dart 2-only Setup

Use our [`over_react_migrate_to_dart2` codemod script][orcm-dart1-and-dart2-to-dart2]
to update your code to a state that is only compatible with Dart 2. This mostly
involves cleaning up the extra boilerplate that was required during the
transition.

[orcm-dart1-to-dart2]: https://github.com/Workiva/over_react_codemod
[orcm-dart1-to-dart1-and-dart2]: https://github.com/Workiva/over_react_codemod
[orcm-dart1-and-dart2-to-dart2]: https://github.com/Workiva/over_react_codemod