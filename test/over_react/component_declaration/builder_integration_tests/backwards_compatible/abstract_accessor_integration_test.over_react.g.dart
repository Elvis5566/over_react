// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'abstract_accessor_integration_test.dart';

// **************************************************************************
// OverReactGenerator
// **************************************************************************

abstract class _$TestAbstractPropsAccessorsMixin
    implements _$TestAbstractProps {
  @override
  Map get props;

  /// Go to [_$TestAbstractProps.stringProp] to see the source code for this prop
  @override
  String get stringProp => props['TestAbstractProps.stringProp'];

  /// Go to [_$TestAbstractProps.stringProp] to see the source code for this prop
  @override
  set stringProp(String value) => props['TestAbstractProps.stringProp'] = value;

  /// Go to [_$TestAbstractProps.dynamicProp] to see the source code for this prop
  @override
  dynamic get dynamicProp => props['TestAbstractProps.dynamicProp'];

  /// Go to [_$TestAbstractProps.dynamicProp] to see the source code for this prop
  @override
  set dynamicProp(dynamic value) =>
      props['TestAbstractProps.dynamicProp'] = value;

  /// Go to [_$TestAbstractProps.untypedProp] to see the source code for this prop
  @override
  get untypedProp => props['TestAbstractProps.untypedProp'];

  /// Go to [_$TestAbstractProps.untypedProp] to see the source code for this prop
  @override
  set untypedProp(value) => props['TestAbstractProps.untypedProp'] = value;

  /// Go to [_$TestAbstractProps.customKeyProp] to see the source code for this prop
  @override
  @Accessor(key: 'custom key!')
  get customKeyProp => props['TestAbstractProps.custom key!'];

  /// Go to [_$TestAbstractProps.customKeyProp] to see the source code for this prop
  @override
  @Accessor(key: 'custom key!')
  set customKeyProp(value) => props['TestAbstractProps.custom key!'] = value;

  /// Go to [_$TestAbstractProps.customNamespaceProp] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  get customNamespaceProp => props['custom namespace~~customNamespaceProp'];

  /// Go to [_$TestAbstractProps.customNamespaceProp] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  set customNamespaceProp(value) =>
      props['custom namespace~~customNamespaceProp'] = value;

  /// Go to [_$TestAbstractProps.customKeyAndNamespaceProp] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  get customKeyAndNamespaceProp => props['custom namespace~~custom key!'];

  /// Go to [_$TestAbstractProps.customKeyAndNamespaceProp] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  set customKeyAndNamespaceProp(value) =>
      props['custom namespace~~custom key!'] = value;
  /* GENERATED CONSTANTS */
  static const List<PropDescriptor> $props = const [
    const PropDescriptor('TestAbstractProps.stringProp'),
    const PropDescriptor('TestAbstractProps.dynamicProp'),
    const PropDescriptor('TestAbstractProps.untypedProp'),
    const PropDescriptor('TestAbstractProps.custom key!'),
    const PropDescriptor('custom namespace~~customNamespaceProp'),
    const PropDescriptor('custom namespace~~custom key!')
  ];
  static const List<String> $propKeys = const [
    'TestAbstractProps.stringProp',
    'TestAbstractProps.dynamicProp',
    'TestAbstractProps.untypedProp',
    'TestAbstractProps.custom key!',
    'custom namespace~~customNamespaceProp',
    'custom namespace~~custom key!'
  ];
}

const PropsMeta _$metaForTestAbstractProps = const PropsMeta(
  fields: _$TestAbstractPropsAccessorsMixin.$props,
  keys: _$TestAbstractPropsAccessorsMixin.$propKeys,
);

abstract class _$TestCustomNamespaceAbstractPropsAccessorsMixin
    implements _$TestCustomNamespaceAbstractProps {
  @override
  Map get props;

  /// Go to [_$TestCustomNamespaceAbstractProps.stringProp] to see the source code for this prop
  @override
  String get stringProp => props['custom mixin namespace**stringProp'];

  /// Go to [_$TestCustomNamespaceAbstractProps.stringProp] to see the source code for this prop
  @override
  set stringProp(String value) =>
      props['custom mixin namespace**stringProp'] = value;

  /// Go to [_$TestCustomNamespaceAbstractProps.dynamicProp] to see the source code for this prop
  @override
  dynamic get dynamicProp => props['custom mixin namespace**dynamicProp'];

  /// Go to [_$TestCustomNamespaceAbstractProps.dynamicProp] to see the source code for this prop
  @override
  set dynamicProp(dynamic value) =>
      props['custom mixin namespace**dynamicProp'] = value;

  /// Go to [_$TestCustomNamespaceAbstractProps.untypedProp] to see the source code for this prop
  @override
  get untypedProp => props['custom mixin namespace**untypedProp'];

  /// Go to [_$TestCustomNamespaceAbstractProps.untypedProp] to see the source code for this prop
  @override
  set untypedProp(value) =>
      props['custom mixin namespace**untypedProp'] = value;

  /// Go to [_$TestCustomNamespaceAbstractProps.customKeyProp] to see the source code for this prop
  @override
  @Accessor(key: 'custom key!')
  get customKeyProp => props['custom mixin namespace**custom key!'];

  /// Go to [_$TestCustomNamespaceAbstractProps.customKeyProp] to see the source code for this prop
  @override
  @Accessor(key: 'custom key!')
  set customKeyProp(value) =>
      props['custom mixin namespace**custom key!'] = value;

  /// Go to [_$TestCustomNamespaceAbstractProps.customNamespaceProp] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  get customNamespaceProp => props['custom namespace~~customNamespaceProp'];

  /// Go to [_$TestCustomNamespaceAbstractProps.customNamespaceProp] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  set customNamespaceProp(value) =>
      props['custom namespace~~customNamespaceProp'] = value;

  /// Go to [_$TestCustomNamespaceAbstractProps.customKeyAndNamespaceProp] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  get customKeyAndNamespaceProp => props['custom namespace~~custom key!'];

  /// Go to [_$TestCustomNamespaceAbstractProps.customKeyAndNamespaceProp] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  set customKeyAndNamespaceProp(value) =>
      props['custom namespace~~custom key!'] = value;
  /* GENERATED CONSTANTS */
  static const List<PropDescriptor> $props = const [
    const PropDescriptor('custom mixin namespace**stringProp'),
    const PropDescriptor('custom mixin namespace**dynamicProp'),
    const PropDescriptor('custom mixin namespace**untypedProp'),
    const PropDescriptor('custom mixin namespace**custom key!'),
    const PropDescriptor('custom namespace~~customNamespaceProp'),
    const PropDescriptor('custom namespace~~custom key!')
  ];
  static const List<String> $propKeys = const [
    'custom mixin namespace**stringProp',
    'custom mixin namespace**dynamicProp',
    'custom mixin namespace**untypedProp',
    'custom mixin namespace**custom key!',
    'custom namespace~~customNamespaceProp',
    'custom namespace~~custom key!'
  ];
}

const PropsMeta _$metaForTestCustomNamespaceAbstractProps = const PropsMeta(
  fields: _$TestCustomNamespaceAbstractPropsAccessorsMixin.$props,
  keys: _$TestCustomNamespaceAbstractPropsAccessorsMixin.$propKeys,
);

abstract class _$TestAbstractStateAccessorsMixin
    implements _$TestAbstractState {
  @override
  Map get state;

  /// Go to [_$TestAbstractState.stringState] to see the source code for this prop
  @override
  String get stringState => state['TestAbstractState.stringState'];

  /// Go to [_$TestAbstractState.stringState] to see the source code for this prop
  @override
  set stringState(String value) =>
      state['TestAbstractState.stringState'] = value;

  /// Go to [_$TestAbstractState.dynamicState] to see the source code for this prop
  @override
  dynamic get dynamicState => state['TestAbstractState.dynamicState'];

  /// Go to [_$TestAbstractState.dynamicState] to see the source code for this prop
  @override
  set dynamicState(dynamic value) =>
      state['TestAbstractState.dynamicState'] = value;

  /// Go to [_$TestAbstractState.untypedState] to see the source code for this prop
  @override
  get untypedState => state['TestAbstractState.untypedState'];

  /// Go to [_$TestAbstractState.untypedState] to see the source code for this prop
  @override
  set untypedState(value) => state['TestAbstractState.untypedState'] = value;

  /// Go to [_$TestAbstractState.customKeyState] to see the source code for this prop
  @override
  @Accessor(key: 'custom key!')
  get customKeyState => state['TestAbstractState.custom key!'];

  /// Go to [_$TestAbstractState.customKeyState] to see the source code for this prop
  @override
  @Accessor(key: 'custom key!')
  set customKeyState(value) => state['TestAbstractState.custom key!'] = value;

  /// Go to [_$TestAbstractState.customNamespaceState] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  get customNamespaceState => state['custom namespace~~customNamespaceState'];

  /// Go to [_$TestAbstractState.customNamespaceState] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  set customNamespaceState(value) =>
      state['custom namespace~~customNamespaceState'] = value;

  /// Go to [_$TestAbstractState.customKeyAndNamespaceState] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  get customKeyAndNamespaceState => state['custom namespace~~custom key!'];

  /// Go to [_$TestAbstractState.customKeyAndNamespaceState] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  set customKeyAndNamespaceState(value) =>
      state['custom namespace~~custom key!'] = value;
  /* GENERATED CONSTANTS */
  static const List<StateDescriptor> $state = const [
    const StateDescriptor('TestAbstractState.stringState'),
    const StateDescriptor('TestAbstractState.dynamicState'),
    const StateDescriptor('TestAbstractState.untypedState'),
    const StateDescriptor('TestAbstractState.custom key!'),
    const StateDescriptor('custom namespace~~customNamespaceState'),
    const StateDescriptor('custom namespace~~custom key!')
  ];
  static const List<String> $stateKeys = const [
    'TestAbstractState.stringState',
    'TestAbstractState.dynamicState',
    'TestAbstractState.untypedState',
    'TestAbstractState.custom key!',
    'custom namespace~~customNamespaceState',
    'custom namespace~~custom key!'
  ];
}

const StateMeta _$metaForTestAbstractState = const StateMeta(
  fields: _$TestAbstractStateAccessorsMixin.$state,
  keys: _$TestAbstractStateAccessorsMixin.$stateKeys,
);

abstract class _$TestCustomNamespaceAbstractStateAccessorsMixin
    implements _$TestCustomNamespaceAbstractState {
  @override
  Map get state;

  /// Go to [_$TestCustomNamespaceAbstractState.stringState] to see the source code for this prop
  @override
  String get stringState => state['custom mixin namespace**stringState'];

  /// Go to [_$TestCustomNamespaceAbstractState.stringState] to see the source code for this prop
  @override
  set stringState(String value) =>
      state['custom mixin namespace**stringState'] = value;

  /// Go to [_$TestCustomNamespaceAbstractState.dynamicState] to see the source code for this prop
  @override
  dynamic get dynamicState => state['custom mixin namespace**dynamicState'];

  /// Go to [_$TestCustomNamespaceAbstractState.dynamicState] to see the source code for this prop
  @override
  set dynamicState(dynamic value) =>
      state['custom mixin namespace**dynamicState'] = value;

  /// Go to [_$TestCustomNamespaceAbstractState.untypedState] to see the source code for this prop
  @override
  get untypedState => state['custom mixin namespace**untypedState'];

  /// Go to [_$TestCustomNamespaceAbstractState.untypedState] to see the source code for this prop
  @override
  set untypedState(value) =>
      state['custom mixin namespace**untypedState'] = value;

  /// Go to [_$TestCustomNamespaceAbstractState.customKeyState] to see the source code for this prop
  @override
  @Accessor(key: 'custom key!')
  get customKeyState => state['custom mixin namespace**custom key!'];

  /// Go to [_$TestCustomNamespaceAbstractState.customKeyState] to see the source code for this prop
  @override
  @Accessor(key: 'custom key!')
  set customKeyState(value) =>
      state['custom mixin namespace**custom key!'] = value;

  /// Go to [_$TestCustomNamespaceAbstractState.customNamespaceState] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  get customNamespaceState => state['custom namespace~~customNamespaceState'];

  /// Go to [_$TestCustomNamespaceAbstractState.customNamespaceState] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  set customNamespaceState(value) =>
      state['custom namespace~~customNamespaceState'] = value;

  /// Go to [_$TestCustomNamespaceAbstractState.customKeyAndNamespaceState] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  get customKeyAndNamespaceState => state['custom namespace~~custom key!'];

  /// Go to [_$TestCustomNamespaceAbstractState.customKeyAndNamespaceState] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  set customKeyAndNamespaceState(value) =>
      state['custom namespace~~custom key!'] = value;
  /* GENERATED CONSTANTS */
  static const List<StateDescriptor> $state = const [
    const StateDescriptor('custom mixin namespace**stringState'),
    const StateDescriptor('custom mixin namespace**dynamicState'),
    const StateDescriptor('custom mixin namespace**untypedState'),
    const StateDescriptor('custom mixin namespace**custom key!'),
    const StateDescriptor('custom namespace~~customNamespaceState'),
    const StateDescriptor('custom namespace~~custom key!')
  ];
  static const List<String> $stateKeys = const [
    'custom mixin namespace**stringState',
    'custom mixin namespace**dynamicState',
    'custom mixin namespace**untypedState',
    'custom mixin namespace**custom key!',
    'custom namespace~~customNamespaceState',
    'custom namespace~~custom key!'
  ];
}

const StateMeta _$metaForTestCustomNamespaceAbstractState = const StateMeta(
  fields: _$TestCustomNamespaceAbstractStateAccessorsMixin.$state,
  keys: _$TestCustomNamespaceAbstractStateAccessorsMixin.$stateKeys,
);
