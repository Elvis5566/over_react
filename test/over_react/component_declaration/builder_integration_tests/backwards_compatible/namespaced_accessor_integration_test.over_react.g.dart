// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'namespaced_accessor_integration_test.dart';

// **************************************************************************
// OverReactGenerator
// **************************************************************************

// React component factory implementation.
//
// Registers component implementation and links type meta to builder factory.
final $NamespacedAccessorTestComponentFactory = registerComponent(
    () => new _$NamespacedAccessorTestComponent(),
    builderFactory: NamespacedAccessorTest,
    componentClass: NamespacedAccessorTestComponent,
    isWrapper: false,
    parentType: null,
    displayName: 'NamespacedAccessorTest');

abstract class _$NamespacedAccessorTestPropsAccessorsMixin
    implements _$NamespacedAccessorTestProps {
  @override
  Map get props;

  /// Go to [_$NamespacedAccessorTestProps.stringProp] to see the source code for this prop
  @override
  String get stringProp => props['custom props class namespace**stringProp'];

  /// Go to [_$NamespacedAccessorTestProps.stringProp] to see the source code for this prop
  @override
  set stringProp(String value) =>
      props['custom props class namespace**stringProp'] = value;

  /// Go to [_$NamespacedAccessorTestProps.dynamicProp] to see the source code for this prop
  @override
  dynamic get dynamicProp => props['custom props class namespace**dynamicProp'];

  /// Go to [_$NamespacedAccessorTestProps.dynamicProp] to see the source code for this prop
  @override
  set dynamicProp(dynamic value) =>
      props['custom props class namespace**dynamicProp'] = value;

  /// Go to [_$NamespacedAccessorTestProps.untypedProp] to see the source code for this prop
  @override
  get untypedProp => props['custom props class namespace**untypedProp'];

  /// Go to [_$NamespacedAccessorTestProps.untypedProp] to see the source code for this prop
  @override
  set untypedProp(value) =>
      props['custom props class namespace**untypedProp'] = value;

  /// Go to [_$NamespacedAccessorTestProps.customKeyProp] to see the source code for this prop
  @override
  @Accessor(key: 'custom key!')
  get customKeyProp => props['custom props class namespace**custom key!'];

  /// Go to [_$NamespacedAccessorTestProps.customKeyProp] to see the source code for this prop
  @override
  @Accessor(key: 'custom key!')
  set customKeyProp(value) =>
      props['custom props class namespace**custom key!'] = value;

  /// Go to [_$NamespacedAccessorTestProps.customNamespaceProp] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  get customNamespaceProp => props['custom namespace~~customNamespaceProp'];

  /// Go to [_$NamespacedAccessorTestProps.customNamespaceProp] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  set customNamespaceProp(value) =>
      props['custom namespace~~customNamespaceProp'] = value;

  /// Go to [_$NamespacedAccessorTestProps.customKeyAndNamespaceProp] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  get customKeyAndNamespaceProp => props['custom namespace~~custom key!'];

  /// Go to [_$NamespacedAccessorTestProps.customKeyAndNamespaceProp] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  set customKeyAndNamespaceProp(value) =>
      props['custom namespace~~custom key!'] = value;
  /* GENERATED CONSTANTS */
  static const List<PropDescriptor> $props = const [
    const PropDescriptor('custom props class namespace**stringProp'),
    const PropDescriptor('custom props class namespace**dynamicProp'),
    const PropDescriptor('custom props class namespace**untypedProp'),
    const PropDescriptor('custom props class namespace**custom key!'),
    const PropDescriptor('custom namespace~~customNamespaceProp'),
    const PropDescriptor('custom namespace~~custom key!')
  ];
  static const List<String> $propKeys = const [
    'custom props class namespace**stringProp',
    'custom props class namespace**dynamicProp',
    'custom props class namespace**untypedProp',
    'custom props class namespace**custom key!',
    'custom namespace~~customNamespaceProp',
    'custom namespace~~custom key!'
  ];
}

const PropsMeta _$metaForNamespacedAccessorTestProps = const PropsMeta(
  fields: _$NamespacedAccessorTestPropsAccessorsMixin.$props,
  keys: _$NamespacedAccessorTestPropsAccessorsMixin.$propKeys,
);

_$$NamespacedAccessorTestProps _$NamespacedAccessorTest([Map backingProps]) =>
    new _$$NamespacedAccessorTestProps(backingProps);

// Concrete props implementation.
//
// Implements constructor and backing map, and links up to generated component factory.
class _$$NamespacedAccessorTestProps extends _$NamespacedAccessorTestProps
    with _$NamespacedAccessorTestPropsAccessorsMixin
    implements NamespacedAccessorTestProps {
  _$$NamespacedAccessorTestProps(Map backingMap)
      : this._props = backingMap ?? {};

  /// The backing props map proxied by this class.
  @override
  Map get props => _props;
  final Map _props;

  /// Let [UiProps] internals know that this class has been generated.
  @override
  bool get $isClassGenerated => true;

  /// The [ReactComponentFactory] associated with the component built by this class.
  @override
  ReactComponentFactoryProxy get componentFactory =>
      $NamespacedAccessorTestComponentFactory;

  /// The default namespace for the prop getters/setters generated for this class.
  @override
  String get propKeyNamespace => 'custom props class namespace**';
}

abstract class _$NamespacedAccessorTestStateAccessorsMixin
    implements _$NamespacedAccessorTestState {
  @override
  Map get state;

  /// Go to [_$NamespacedAccessorTestState.stringState] to see the source code for this prop
  @override
  String get stringState => state['custom state class namespace**stringState'];

  /// Go to [_$NamespacedAccessorTestState.stringState] to see the source code for this prop
  @override
  set stringState(String value) =>
      state['custom state class namespace**stringState'] = value;

  /// Go to [_$NamespacedAccessorTestState.dynamicState] to see the source code for this prop
  @override
  dynamic get dynamicState =>
      state['custom state class namespace**dynamicState'];

  /// Go to [_$NamespacedAccessorTestState.dynamicState] to see the source code for this prop
  @override
  set dynamicState(dynamic value) =>
      state['custom state class namespace**dynamicState'] = value;

  /// Go to [_$NamespacedAccessorTestState.untypedState] to see the source code for this prop
  @override
  get untypedState => state['custom state class namespace**untypedState'];

  /// Go to [_$NamespacedAccessorTestState.untypedState] to see the source code for this prop
  @override
  set untypedState(value) =>
      state['custom state class namespace**untypedState'] = value;

  /// Go to [_$NamespacedAccessorTestState.customKeyState] to see the source code for this prop
  @override
  @Accessor(key: 'custom key!')
  get customKeyState => state['custom state class namespace**custom key!'];

  /// Go to [_$NamespacedAccessorTestState.customKeyState] to see the source code for this prop
  @override
  @Accessor(key: 'custom key!')
  set customKeyState(value) =>
      state['custom state class namespace**custom key!'] = value;

  /// Go to [_$NamespacedAccessorTestState.customNamespaceState] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  get customNamespaceState => state['custom namespace~~customNamespaceState'];

  /// Go to [_$NamespacedAccessorTestState.customNamespaceState] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~')
  set customNamespaceState(value) =>
      state['custom namespace~~customNamespaceState'] = value;

  /// Go to [_$NamespacedAccessorTestState.customKeyAndNamespaceState] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  get customKeyAndNamespaceState => state['custom namespace~~custom key!'];

  /// Go to [_$NamespacedAccessorTestState.customKeyAndNamespaceState] to see the source code for this prop
  @override
  @Accessor(keyNamespace: 'custom namespace~~', key: 'custom key!')
  set customKeyAndNamespaceState(value) =>
      state['custom namespace~~custom key!'] = value;
  /* GENERATED CONSTANTS */
  static const List<StateDescriptor> $state = const [
    const StateDescriptor('custom state class namespace**stringState'),
    const StateDescriptor('custom state class namespace**dynamicState'),
    const StateDescriptor('custom state class namespace**untypedState'),
    const StateDescriptor('custom state class namespace**custom key!'),
    const StateDescriptor('custom namespace~~customNamespaceState'),
    const StateDescriptor('custom namespace~~custom key!')
  ];
  static const List<String> $stateKeys = const [
    'custom state class namespace**stringState',
    'custom state class namespace**dynamicState',
    'custom state class namespace**untypedState',
    'custom state class namespace**custom key!',
    'custom namespace~~customNamespaceState',
    'custom namespace~~custom key!'
  ];
}

const StateMeta _$metaForNamespacedAccessorTestState = const StateMeta(
  fields: _$NamespacedAccessorTestStateAccessorsMixin.$state,
  keys: _$NamespacedAccessorTestStateAccessorsMixin.$stateKeys,
);

// Concrete state implementation.
//
// Implements constructor and backing map.
class _$$NamespacedAccessorTestState extends _$NamespacedAccessorTestState
    with _$NamespacedAccessorTestStateAccessorsMixin
    implements NamespacedAccessorTestState {
  _$$NamespacedAccessorTestState(Map backingMap)
      : this._state = backingMap ?? {};

  /// The backing state map proxied by this class.
  @override
  Map get state => _state;
  final Map _state;

  /// Let [UiState] internals know that this class has been generated.
  @override
  bool get $isClassGenerated => true;
}

// Concrete component implementation mixin.
//
// Implements typed props/state factories, defaults `consumedPropKeys` to the keys
// generated for the associated props class.
class _$NamespacedAccessorTestComponent
    extends NamespacedAccessorTestComponent {
  @override
  _$$NamespacedAccessorTestProps typedPropsFactory(Map backingMap) =>
      new _$$NamespacedAccessorTestProps(backingMap);

  @override
  _$$NamespacedAccessorTestState typedStateFactory(Map backingMap) =>
      new _$$NamespacedAccessorTestState(backingMap);

  /// Let [UiComponent] internals know that this class has been generated.
  @override
  bool get $isClassGenerated => true;

  /// The default consumed props, taken from _$NamespacedAccessorTestProps.
  /// Used in [UiProps.consumedProps] if [consumedProps] is not overridden.
  @override
  final List<ConsumedProps> $defaultConsumedProps = const [
    _$metaForNamespacedAccessorTestProps
  ];
}
